// flatbuffer-tcp.cpp : This file contains the 'main' function. Program execution begins and ends there.

/*
C++ Development Assignment

Research on the Google FlatBuffers projects (https://google.github.io/flatbuffers/) and work on following tasks:

Write a sample schema that can represent a property tree (property name, property value, property type, and sub-properties).

Write code snippets in C++ that can read/update on the property object generated by the FlatBuffers compiler.

Write code snippets in C++ that can send/receive the property object over TCP socket.

Write code snippets in C++ that use the reflection API to read from the TCP socket and iterate over the elements stored inside the property tree.

Consider the property tree will be updated frequently by the sender, think of a solution that synchronize the updates to the receiver.

*/

#include "fb_property_manager.h"
#include "basic_tcp_server.h"
#include "basic_tcp_client.h"

#include <thread>

constexpr unsigned int buflen = 1024;

int main(int argc, char* argv[])
{
    if (argc == 1) // Server mode
    {
        char buffer[buflen];
        BasicTcpServer server;
        std::thread server_thread([&]() { server.Listen(buffer, buflen); });
        server_thread.join();
    }
    else // Client mode
    {
        BasicTcpClient client;

        // create some dummy tree that increases in size to send over
        auto root = std::make_shared<Property>("root", 0, 0);
        auto property = root;
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 5; j++)
            {
                property->SetSubproperty(std::make_shared<Property>(std::to_string(i*5+j), i, j));
            }
            property = property->GetSubproperties().begin()->second;

            std::thread client_thread([&]() { client.Send(root, buflen); });
            client_thread.join();
            Sleep(3000);
        }

        //while (true)
        //{
        //    std::thread client_thread([&]() { client.Send(root, buflen); });
        //    client_thread.join();
        //    Sleep(3000);
        //}
    }

    return 0;
}
